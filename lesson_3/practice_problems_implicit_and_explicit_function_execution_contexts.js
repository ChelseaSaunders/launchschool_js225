// NOTE: REAL ASSIGNMENT DONE IN CHROME SNIPPETS!!
// Just saving here for reference/posterity.

// What will the code below output?

function foo() {
  return this;
}

let context = foo();
console.log(context);

// window

// What will the code in the previous question output in strict mode?
// undefined

// LS Answer:
// The return value of foo is the global this, which is undefined in strict
// mode.

// What will the code below output? Explain the difference, if any, between this
// output and that of problem 1.

let obj = {
  foo() {
    return this;
  },
};

let context = obj.foo();

console.log(context);

// {foo: f}

// Unlike problem 1, this code outputs the object obj. This happens since foo is
// invoked as a method. Thus, its execution context refers to the object used
// to call the function.

// What will the code below output?

var message = 'Hello from the global scope!';

function deliverMessage() {
  console.log(this.message);
}

deliverMessage();

let bar = {
  message: 'Hello from the function scope!',
};

bar.deliverMessage = deliverMessage;

bar.deliverMessage();

Hello from the global scope!
Hello from the function scope!

// The first log operation is generated by the function call, deliverMessage()
// on line 7. Since this is a function invocation, the implicit function
// execution context is the global object, Window. That means that JavaScript
// looks in Window for the variable message.

// The second log operation is generated by the method call bar.deliverMessage()
// on line 15. Since the implicit function execution context for a method
// invocation is the calling object, this resolves to bar, and this.message
// resolves to bar's property message.

// What will the code below output? What would happen if we replaced var on line
//  1 with let? Can you explain why the output changes?

var a = 10;
let b = 10;
let c = {
  a: -10,
  b: -10,
};

function add() {
  return this.a + b;
}

c.add = add;

console.log(add()); // 20 -- both global scope
console.log(c.add()); // 0 this.a is in function scope

// if there was a let on line 72 instead
With let on line 1

NaN
0

// As in question 3, the key detail here is that the first invocation of add is
// as a function, while the second invocation is as a method. In the function
// invocation, on line 14, this resolves to the global object, and the property
// a to the value 10. In the method invocation, however, this resolves to the
// object c, and the property a to the value -10. In both cases a simple
// reference to b.

// When we replaced var with let, the output of the function call is NaN, not
// 20. This happens because global var variables create properties on the global
// object, but let and const create variables that don't belong to any object.


// The problems above all feature implicit function execution context. What
// methods have we learned so far that let us explicitly specify what a
// function's execution context should be?

// .call and .apply


// In the code below, use call to invoke add as a method on bar, but with foo as
//  the execution context. What will this return?

// let foo = {
//   a: 1,
//   b: 2,
// };

// let bar = {
//    a: 'abc',
//    b: 'def',
//    add() {
//      return this.a + this.b;
//    },
// };


// bar.add.call(foo) // 3

// Given the code and desired output shown below, should you use call or apply
// to supply explicit context and the arguments to outputList? That is, which
// method makes the most sense to use? Implement a solution using your preferred
// method such that the desired output is logged, and explain your choice.

// let fruitsObj = {
//   list: ['Apple', 'Banana', 'Grapefruit', 'Pineapple', 'Orange'],
//   title: 'A Collection of Fruit',
// };

// function outputList() {
//   console.log(this.title + ':');

//   let args = [].slice.call(arguments);

//   args.forEach(function(elem) {
//     console.log(elem);
//   });
// }

// // invoke outputList here
// outputList.apply(fruitsObj, fruitsObj.list);

// Desired output:

// A Collection of Fruit:
// Apple
// Banana
// Grapefruit
// Pineapple
// Orange

// apply takes an array of arguments to be passed to the invoked function,
// rather than call's comma-separated arguments. Since the data we are concerned
// with (fruitsObj.list) is held in Array format, it makes more sense to use
// apply.

// A more modern solution for this problem uses call and the new "spread syntax"
// touched on in our Syntactic Sugar gist:

// outputList.call(fruitsObj, ...fruitsObj.list);

// For an extra challenge, consider this line of code from the previous problem:

let args = [].slice.call(arguments);

// Inside of JavaScript functions, arguments is an object that holds all of the
// arguments passed to the function. Bearing in mind that the function author
// wants to iterate over the arguments later in the method using an Array
// method, why do you think he or she is invoking call?

// It isn't possible to call forEach on arguments since it is only Array-like
// and not an array. However, since it is Array-like (having indices from 0 to
// length - 1) we can use it as the context to a slice method call on an empty
// array. The return value assigned to args is an array holding all of the
// arguments passed to the outputList function since we are executing slice with
// no arguments passed to it (recall: the first value passed to call is the
// execution context).

// Modern JavaScript doesn't use the built-in arguments object. Instead, it uses
// the new rest syntax that we discuss in our Syntactic Sugar gist:

let fruitsObj = {
  list: ['Apple', 'Banana', 'Grapefruit', 'Pineapple', 'Orange'],
  title: 'A Collection of Fruit',
};

function outputList(...args) {
  console.log(this.title + ':');

  args.forEach(function(elem) {
    console.log(elem);
  });
// }

// invoke outputList here